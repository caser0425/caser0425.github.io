<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2019%2F10%2F19%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置SSH使用hexo deploy时免输用户名和密码]]></title>
    <url>%2F2019%2F10%2F18%2F%E8%AE%BE%E7%BD%AESSH%E4%BD%BF%E7%94%A8hexo-deploy%E6%97%B6%E5%85%8D%E8%BE%93%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[生成SSH秘钥打开命令行工具，任意位置打开 Git Bash Here 然后输入以下命令 1$ cd ~/.ssh 使用 ssh-keygen 生成密钥1234$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;# Creates a new ssh key using the provided emailGenerating public/private rsa key pair.Enter file in which to save the key (/home/you/.ssh/id_rsa): 使用默认的文件名直接enter，接下来显示如下 12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 按提示输入密码即可（简化流程的话在键入命令ssh-keygen -t rsa -C “your_email@example.com“ 以后的三次提示输入都可以直接回车跳过）。 密钥生成成功 1234Your identification has been saved in /home/you/.ssh/id_rsa.Your public key has been saved in /home/you/.ssh/id_rsa.pub.The key fingerprint is:…………………此处是密钥内容…………………… your_email@example.com 设置Github 项目的 Deploy keys可以选择是在用户设置中添加密钥（Settings –&gt; SSH GPG keys）还是单个项目中添加密钥，在这里我就在我们的博客项目中添加密钥，此处以我的博客为例。在 caser04255.github.io 的首页菜单栏中点击 Settings –&gt; Deploy keys –&gt; Add deploy key，然后将生成的 id_rsa.pub 中的内容全选复制到 key 输入框中，然后点击 Add key 完成添加公钥。 接下来测试配置是否成功 1ssh -T git@github.com 如果出现以下内容即表示配置完成并且成功！ 12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 设置博客提交地址hexo 的配置文件 _config.yml 中的deploy 属性。12345deploy: type: git repo: git@github.com:caser0425/caser0425.github.io.git branch: master message: 将repo改成 git@github.com:username/username.github.io.git 就可以了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类与对象]]></title>
    <url>%2F2019%2F10%2F18%2FJava%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类类的定义Java中类的定义基本格式： 123[类修饰符] class &lt;类名&gt;&#123; &lt;类体&gt;&#125; 类修饰符用public或默认 类名第一个字母要大写 类体可缺省 类体由变量定义和方法定义组成 类的成员变量声明格式： 12[修饰符] &lt;类型&gt; &lt;变量名&gt; [=初始值];private String name = &quot;Tom&quot;; 类的成员方法声明格式： 123[修饰符] &lt;返回值&gt;&lt; 方法名&gt; (形参列表)&#123; &lt;方法体&gt;&#125; 变量初始化 成员变量未初始化会使用默认的初始化值 类的方法方法定义方法定义的格式 123[修饰符] &lt;返回值类型&gt; &lt;方法名&gt; [&lt;形式参数列表&gt;]&#123; &lt;方法体&gt;&#125; 返回值可以是任意类型 如果没有返回值，类型定义为 void &lt;形式参数列表&gt;是该方法接收的输入值和相应类型 方法体可以缺省 参数传递Java规定所有参数传递都为“值传递”。机制是：首先从左到右计算各个实参的值，然后在运行栈为形参非配空间，再为该方法其他局部参数分配空间，计算的实参的值分配到形参变量空间中。运行完成自动删除该方法所有信息。 递归 直接递归 间接递归 方法重载方法重载是指一个类中可以定义有相同名字，但参数不同的多个方法。各方法之间的参数个数，参数顺序，类型不同不可以构成重载。 123456789void f(int x)&#123; ...&#125;void f(int x,int y)&#123; ...&#125;void f(int x,String s)&#123; ...&#125; 创建对象对象即类的实例化。 构造方法构造方法语法规则 方法必须与类名相同 不用声明返回类型 不能被static、final、synchronized、abstract、和native修饰。 默认构造方法未设置构造方法会自动生成无参构造方法 构造方法重载通过改变方法中的参数来重载，至少要有默认构造方法 this 引用this是Java的关键字，用于表示对象自身的引用。 类的static方法中，是不能使用this的。 this是调用当前对象的值。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2019%2F10%2F18%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组一维数组定义123456格式1：&lt;类型&gt; &lt;数组名&gt;[];格式2：&lt;类型&gt;[] &lt;数组名&gt;;int a[];String[] person;int b[100];不能在定义时指定长度 创建一维数组对象123数组名 = new 元素类型 [元素个数];int[] Arry = new int[100]; 数组初始化静态初始化1int[] Arry = &#123;1,2,3,4&#125; 动态初始化12345678int a[] = new int[3];a[0]=1; a[1]=5; a[2]=3;引用类型也可初始化Point[] Pa = new Point[3];Pa[0] = new Point(1,2);Pa[1] = new Point(1,4);Pa[2] = new Point(3,9); 多维数组123456格式1：&lt;类型&gt; &lt;数组名&gt;[][];格式2：&lt;类型&gt;[][] &lt;数组名&gt;;int a[][];String[][] person;int b[100][100];不能在定义时指定长度 创建二维数组对象123数组名 = new 元素类型 [元素个数][元素个数];int[][] a = new int[2][3]; 数组初始化静态初始化123String[][] alphabet = &#123;&#123;&quot;a&quot;,&quot;b&quot;.&quot;c&quot;&#125;,&#123;&quot;d&quot;,&quot;f&quot;,&quot;g&quot;&#125;,&#123;&quot;h&quot;,&quot;y&quot;,&quot;z&quot;&#125;&#125;String[4][3] alphabet = &#123;&#123;&quot;a&quot;,&quot;b&quot;.&quot;c&quot;&#125;,&#123;&quot;d&quot;,&quot;f&quot;,&quot;g&quot;&#125;,&#123;&quot;h&quot;,&quot;y&quot;,&quot;z&quot;&#125;&#125;//初始化不可以指定长度 动态初始化1234567方法一int[][] arr = new int[3][4];方法二int[][] c = new int[3][];c[0] = mew int[3];c[1] = mew int[4];c[2] = mew int[5];]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HandlerInterceptor拦截器的使用]]></title>
    <url>%2F2019%2F10%2F12%2FHandlerInterceptor%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[HandlerInterceptor拦截器的使用 HandlerInterceptor简介 拦截器我想大家都并不陌生，最常用的登录拦截、或是权限校验、或是防重复提交、或是根据业务像12306去校验购票时间,总之可以去做很多的事情。 1、定义实现类定义一个Interceptor 非常简单方式也有几种，我这里简单列举两种 1、类要实现Spring 的HandlerInterceptor 接口 2、类继承实现了HandlerInterceptor 接口的类，例如 已经提供的实现了HandlerInterceptor 接口的抽象类HandlerInterceptorAdapter 2、HandlerInterceptor方法介绍12345678910 boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception;void afterCompletion( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception; preHandle：在业务处理器处理请求之前被调用。预处理，可以进行编码、安全控制、权限校验等处理； postHandle：在业务处理器处理请求执行完成后，生成视图之前执行。后处理（调用了Service并返回ModelAndView，但未进行页面渲染），有机会修改ModelAndView ； afterCompletion：在DispatcherServlet完全处理完请求后被调用，可用于清理资源等。返回处理（已经渲染了页面）； 拦截器方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.tdschool.interceptor;import java.util.Random;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import com.tdschool.utils.MUtils;public class TokenInterceptor implements HandlerInterceptor &#123; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception exception) throws Exception &#123; // TODO Auto-generated method stub &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelView) throws Exception &#123; // TODO Auto-generated method stub &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // TODO 判断是否有自定义的注解 if(handler==null||!(handler instanceof HandlerMethod)) return true;// 代表继续执行下一步=》 进入cntroller UserToken token= ((HandlerMethod)handler).getMethodAnnotation(UserToken.class); if(token==null)return true; if(token.create())&#123; // TODO 需要生成token String nostr = MUtils.randomString(32); request.getSession().setAttribute(&quot;tokenvalue&quot;, nostr); &#125;else if(token.check())&#123; // TODO 需要进行token验证 String tokenvalue = (String) request.getSession().getAttribute(&quot;tokenvalue&quot;); String requestToke = request.getParameter(&quot;tokenvalue&quot;); if(tokenvalue!=null&amp;&amp;tokenvalue.equals(requestToke))&#123; // TODO 验证成功 直接进入下一步 &#125;else&#123; // TODO 验证失败 返回错误信息 return false; &#125; &#125; return true; &#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 常用指令]]></title>
    <url>%2F2019%2F09%2F01%2Fhexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post如果我们要创建一篇文章的话，我们可以通过new命令来创建，也可以直接在博客目录下面的\source_posts里面创建markdown文件。 1$ hexo new "My New Post" 如果标题包含空格的话，请使用引号括起来。 More info: Writing Run server开启服务器，网址为http://localhost:4000 1$ hexo server More info: Server Generate static filesgenerate命令是用来生成静态文件的，在我们发布到GitHub的仓库的时候，需要先生成，才能上传。 1$ hexo generate 可以简写为 1$ hexo g More info: Generating Deploy to remote sites部署网址，上传到我们的GitHub的仓库上面 1$ hexo deploy 可以简写为 1$ hexo d clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果对站点的更改无论如何也不生效，运行该命令。 1hexo clean 一般我们上传到GitHub的时候我们用这条命令来执行，生成静态文件并且部署到服务器。 1hexo g -d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实战]]></title>
    <url>%2F2019%2F08%2F01%2Fpython%2F</url>
    <content type="text"><![CDATA[Python实战 1. 分段函数求值 123456789101112131415&quot;&quot;&quot;&quot; 3x - 5（x&gt; 1）f（x）= x + 2（-1 &lt;= x &lt;= 1） 5x + 3（x &lt;-1）&quot;&quot;&quot;&quot;&quot;x = float(input(&apos;x = &apos;))if x &gt; 1: y = 3 * x - 5elif x &gt;= -1: y = x + 2else: y = 5 * x + 3print(&apos;f(%.2f) = %.2f&apos; % (x,y)) 2. 1-100求和 12345678910111213141516171819&apos;&apos;&apos;&apos;range(101)可以产生一个0到100的整数序列。range(1, 100)可以产生一个1到99的整数序列。range(1, 100, 2)可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;sum = 0for x in range(101): sum += xprint(sum)&apos;&apos;&apos;&quot;1-100偶数求和&quot;sum = 0for x in range(1,101,2): sum += xprint(sum) 3. 猜数字游戏 1234567891011121314151617181920212223&apos;&apos;&apos;计算机出一个1~100之间的随机数由人来猜计算机根据人猜的数字分别给出提示大一点/小一点/猜对了&apos;&apos;&apos;&apos;&apos;import randomanswer = random.randint(1,100)counter = 0while True: counter +=1 number = int(input(&apos;请输入：&apos;)) if number &lt; answer: print(&apos;比它大&apos;) elif number &gt; answer: print(&apos;比它小&apos;) else: print(&apos;你猜对了&apos;) break #break一定要，不然不会跳出循环print(&apos;你总共猜了%d次&apos; % counter)if counter &gt; 7: print(&apos;智商需要充值&apos;) 4. 用户身份验证 123456789101112131415&quot;&quot;&quot;用户身份验证&quot;&quot;&quot;# import getpass# from getpass import getpass# from getpass import *username = input(&apos;请输入用户名: &apos;)password = input(&apos;请输入口令: &apos;)# 输入口令的时候终端中没有回显# password = getpass.getpass(&apos;请输入口令: &apos;)if username == &apos;admin&apos; and password == &apos;123456&apos;: print(&apos;身份验证成功!&apos;)else: print(&apos;身份验证失败!&apos;) 5. 输出乘法口诀表(九九表) 12345678&quot;&quot;&quot;输出乘法口诀表(九九表)&quot;&quot;&quot;&quot;&quot;for i in range(1,10): for j in range(1,i+1): print(&apos;%d * %d = %d&apos;%(i, j, i * j),end=&apos;\t&apos;) print() 6. 输入一个正整数判断它是不是素数 1234567891011121314151617&quot;&quot;&quot;输入一个正整数判断它是不是素数&quot;&quot;&quot;&quot;&quot;from math import sqrtnum = int(input(&apos;请输入一个正整数;&apos;))end = int(sqrt(num))is_prime = Truefor x in range(2, end + 1): if num % x == 0: is_prime = False breakif is_prime and num != 1: print(&apos;%d是素数&apos; % num)else: print(&apos;%d不是素数&apos; % num) 7. 打印各种三角形图案 123456789101112131415161718192021222324252627282930313233343536373839404142434445&quot;&quot;&quot;打印各种三角形图案*************** * ** *** ********* * *** ***** ****************&quot;&quot;&quot;&quot;&quot;row = int(input(&apos;请输入行数: &apos;))for i in range(row): for _ in range(i + 1): print(&apos;*&apos;, end=&apos;&apos;) print()for i in range(row): for j in range(row): if j &lt; row - i - 1: print(&apos; &apos;, end=&apos;&apos;) else: print(&apos;*&apos;, end=&apos;&apos;) print()for i in range(row): for _ in range(row - i - 1): print(&apos; &apos;, end=&apos;&apos;) for _ in range(2 * i + 1): print(&apos;*&apos;, end=&apos;&apos;) print() 8. 求解《百钱百鸡》问题 12345678910&quot;&quot;&quot;求解《百钱百鸡》问题1只公鸡5元 1只母鸡3元 3只小鸡1元 用100元买100只鸡问公鸡 母鸡 小鸡各有多少只&quot;&quot;&quot;&quot;&quot;for x in range(0,20): for y in range(0,33): z = 100 - x - y if x * 5 + y * 3 + z / 3 == 100: print(&apos;%d只公鸡、%d只母鸡、%d只小鸡。&apos;%(x,y,z)) 9. Craps赌博游戏 123456789101112131415161718192021222324252627282930313233343536373839404142434445&quot;&quot;&quot;Craps赌博游戏玩家摇两颗色子 如果第一次摇出7点或11点 玩家胜如果摇出2点 3点 12点 庄家胜 其他情况游戏继续玩家再次要色子 如果摇出7点 庄家胜如果摇出第一次摇的点数 玩家胜否则游戏继续 玩家继续摇色子玩家进入游戏时有1000元的赌注 全部输光游戏结束&quot;&quot;&quot;&quot;&quot;from random import randintmoney = 1000while money &gt; 0 : print(&apos;你的资产为:%d&apos;%money) needs_go_on = False while True: debt = int(input(&apos;请下注：&apos;)) if debt &gt; 0 and debt &lt;= money : break first = randint(1,6) + randint(1,6) print(&apos;玩家摇出了%d点。&apos;% first) if first == 7 or first == 11: print(&apos;玩家胜&apos;) money += debt elif first == 2 or first == 3 or first == 12 : print(&apos;庄家胜&apos;) money -= debt else: needs_go_on =True while needs_go_on : current = randint(1,6) + randint(1,6) print(&apos;玩家摇出来%d点&apos;%current) if current == 7: print(&apos;庄家胜！&apos;) money -= debt needs_go_on = False elif current == first: print(&apos;玩家胜!&apos;) money += debt needs_go_on = Falseprint(&apos;你破产了，游戏结束！&apos;) 10. 输出斐波那契数列的前20个数 1234567891011&quot;&quot;&quot;输出斐波那契数列的前20个数1 1 2 3 5 8 13 21 ...&quot;&quot;&quot;&quot;&quot;a = 0b = 1for _ in range(20): a, b = b, a + b print(a, end=&apos; &apos;) 11. 水仙花数 12345678910111213&quot;&quot;&quot;找出100~999之间的所有水仙花数水仙花数是各位立方和等于这个数本身的数如: 153 = 1**3 + 5**3 + 3**3&quot;&quot;&quot;&quot;&quot;for num in range(100,1000): low = num % 10 mid = num // 10 % 10 high = num //100 if num == low ** 3 + mid ** 3 + high ** 3: print(num) 12. 判断输入的正整数是不是回文数 12345678910111213141516171819&quot;&quot;&quot;判断输入的正整数是不是回文数回文数是指将一个正整数从左往右排列和从右往左排列值一样的数Version: 0.1Author: 骆昊Date: 2018-03-02&quot;&quot;&quot;&quot;&quot;num = int(input(&apos;请输入一个正整数: &apos;))temp = numnum2 = 0while temp &gt; 0: num2 *= 10 num2 += temp % 10 temp //= 10if num == num2: print(&apos;%d是回文数&apos; % num)else: print(&apos;%d不是回文数&apos; % num) 13. 找出1~9999之间的所有完美数 123456789101112131415161718&quot;&quot;&quot;找出1~9999之间的所有完美数完美数是除自身外其他所有因子的和正好等于这个数本身的数例如: 6 = 1 + 2 + 3, 28 = 1 + 2 + 4 + 7 + 14&quot;&quot;&quot;&quot;&quot;import timeimport mathfor num in range(1, 10000): sum = 0 for factor in range(1, int(math.sqrt(num)) + 1): if num % factor == 0: sum += factor if factor &gt; 1 and num / factor != factor: sum += num / factor if sum == num: print(num) 12345678910111213141516def factorial(num): &quot;&quot;&quot; 求阶乘 :param num:非负整数 :return:阶乘 &quot;&quot;&quot; result = 1 for n in range(1, num + 1): result *= n return resultm = int(input(&apos;m = &apos;))n = int(input(&apos;n = &apos;))print(factorial(m)//factorial(n)//factorial(m - n)) 12345678910111213141516171819202122232425from random import randintdef roll_dice(n = 2): &quot;&quot;&quot; :param n: 色子个数 :return: n 个色字点数的和 &quot;&quot;&quot; sum = 0 for _ in range(n): sum += randint(1,6) return sumdef add(a=0,b=0,c=0): return a + b + cprint(roll_dice())print(roll_dice(3))print(roll_dice(n=4))print(add())print(add(1))print(add(1,2))print(add(1,2,3))print(add(3,2,1))print(add(b=500,c=1000,a=400)) 12345678910111213141516171819&quot;&quot;&quot;输入M和N计算C(M,N)太过于重复使用函数用def定义函数&quot;&quot;&quot;m = int(input(&apos;m = &apos;))n = int(input(&apos;n = &apos;))fm = 1for num in range(1, m + 1): fm *= numfn = 1for num in range(1, n + 1): fn *= numfmn = 1for num in range(1, m - n + 1): fmn *= numprint(fm // fn // fmn) 123456789101112131415161718192021222324252627282930313233343536373839404142434445&quot;&quot;&quot;Craps赌博游戏玩家摇两颗色子 如果第一次摇出7点或11点 玩家胜如果摇出2点 3点 12点 庄家胜 其他情况游戏继续玩家再次要色子 如果摇出7点 庄家胜如果摇出第一次摇的点数 玩家胜否则游戏继续 玩家继续摇色子玩家进入游戏时有1000元的赌注 全部输光游戏结束&quot;&quot;&quot;&quot;&quot;from random import randintmoney = 1000while money &gt; 0 : print(&apos;你的资产为:%d&apos;%money) needs_go_on = False while True: debt = int(input(&apos;请下注：&apos;)) if debt &gt; 0 and debt &lt;= money : break first = randint(1,6) + randint(1,6) print(&apos;玩家摇出了%d点。&apos;% first) if first == 7 or first == 11: print(&apos;玩家胜&apos;) money += debt elif first == 2 or first == 3 or first == 12 : print(&apos;庄家胜&apos;) money -= debt else: needs_go_on =True while needs_go_on : current = randint(1,6) + randint(1,6) print(&apos;玩家摇出来%d点&apos;%current) if current == 7: print(&apos;庄家胜！&apos;) money -= debt needs_go_on = False elif current == first: print(&apos;玩家胜!&apos;) money += debt needs_go_on = Falseprint(&apos;你破产了，游戏结束！&apos;) 1234567891011121314# 在参数名前面的*表示args是一个可变参数# 即在调用add函数时可以传入0个或多个参数def add(*args): total = 0 for val in args: total += val return totalprint(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))print(add(1, 3, 5, 7, 9)) moudle1 12def foo(): print(&apos;hello, world!&apos;) moudle2 12def foo(): print(&apos;goodbye, world!&apos;) test 123456789101112131415from module1 import foo# 输出hello, world!foo()from module2 import foo# 输出goodbye, world!foo()import module1 as m1import module2 as m2m1.foo()m2.foo() moudle3 123456789101112131415def foo(): passdef bar(): pass# __name__是Python中一个隐含的变量它代表了模块的名字# 只有被Python解释器直接执行的模块的名字才是__main__if __name__ == &apos;__main__&apos;: print(&apos;call foo()&apos;) foo() print(&apos;call bar()&apos;) bar() 1234567from module3 import *if __name__ == &apos;__main__&apos;: print(&apos;call foo()&apos;) foo() print(&apos;call bar()&apos;) bar() 1234567891011121314151617def foo(): b = &apos;hello&apos; def bar(): # Python中可以在函数内部再定义函数 c = True print(a) print(b) print(c) bar() # print(c) # NameError: name &apos;c&apos; is not definedif __name__ == &apos;__main__&apos;: a = 100 # print(b) # NameError: name &apos;b&apos; is not defined foo() 12345678def foo(): a = 200 print(a)if __name__ == &apos;__main__&apos;: a = 100 foo() print(a) 12345678910111213141516&quot;&quot;&quot;global 调用全局变量使用global关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，那么下面一行的代码就会定义变量a并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域&quot;&quot;&quot;def foo(): global a a = 200 print(a)if __name__ == &apos;__main__&apos;: a = 100 foo() print(a) nonlocal 12345678def f1(): a = 250 def f2(): nonlocal a a = 520 f2() print(a)f1() # 输出 520 在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收。事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措，同时也是对迪米特法则的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在函数调用结束后依然可以访问，这时候就需要使用闭包 字符串 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def main(): str1 = &apos;hello, world!&apos; # 通过len函数计算字符串的长度 print(len(str1)) # 13 # 获得字符串首字母大写的拷贝 print(str1.capitalize()) # Hello, world! # 获得字符串变大写后的拷贝 print(str1.upper()) # HELLO, WORLD! # 从字符串中查找子串所在位置 print(str1.find(&apos;or&apos;)) # 8 print(str1.find(&apos;shit&apos;)) # -1 # 与find类似但找不到子串时会引发异常 print(str1.index(&apos;or&apos;)) #print(str1.index(&apos;shit&apos;)) # 检查字符串是否以指定的字符串开头 print(str1.startswith(&apos;He&apos;)) # False print(str1.startswith(&apos;hel&apos;)) # True # 检查字符串是否以指定的字符串结尾 print(str1.endswith(&apos;!&apos;)) # True # 将字符串以指定的宽度居中并在两侧填充指定的字符 print(str1.center(50, &apos;*&apos;)) # 将字符串以指定的宽度靠右放置左侧填充指定的字符 print(str1.rjust(50, &apos; &apos;)) str2 = &apos;abc123456&apos; # 从字符串中取出指定位置的字符(下标运算) print(str2[2]) # c # 字符串切片(从指定的开始索引到指定的结束索引) print(str2[2:5]) # c12 print(str2[2:]) # c123456 print(str2[2::2]) # c246 print(str2[::2]) # ac246 print(str2[::-1]) # 654321cba print(str2[-3:-1]) # 45 # 检查字符串是否由数字构成 print(str2.isdigit()) # False # 检查字符串是否以字母构成 print(str2.isalpha()) # False # 检查字符串是否以数字和字母构成 print(str2.isalnum()) # True str3 = &apos; www.python365.club &apos; print(str3) # 获得字符串修剪左右两侧空格的拷贝 print(str3.strip())if __name__ == &apos;__main__&apos;: main() list列表 1234567891011121314151617181920212223242526272829303132333435363738394041424344def main(): list1 = [1, 3, 5, 7, 100] print(list1) list2 = [&apos;hello&apos;] * 5 print(list2) # 计算列表长度(元素个数) print(len(list1)) # 下标(索引)运算 print(list1[0]) print(list1[1]) print(list1[4]) # print(list1[5]) # IndexError: list index out of range print(list1[-1]) print(list1[-3]) list1[2] = 300 print(list1) # 添加元素 list1.append(200) # 插入元素 list1.insert(1, 400) list1 += [1000, 2000] print(list1) print(len(list1)) print(list1) # 删除元素 list1.remove(3) print(list1) if 1 in list1: list1.remove(2000) #该方法没有返回值但是会移除列表中的某个值的第一个匹配项。 print(list1) del list1[0] print(list1) list1.pop() print(list1) # 清空列表元素 list1.clear() print(list1)if __name__ == &apos;__main__&apos;: main() 1234567891011121314151617181920212223def main(): fruits = [&apos;grape&apos;, &apos;apple&apos;, &apos;strawberry&apos;, &apos;waxberry&apos;] fruits += [&apos;pitaya&apos;, &apos;pear&apos;, &apos;mango&apos;] # 循环遍历列表元素 for fruit in fruits: print(fruit.title(), end=&apos; &apos;) print() # 列表切片 fruits2 = fruits[1:4] print(fruits2) # fruit3 = fruits # 没有复制列表只创建了新的引用 # 可以通过完整切片操作来复制列表 fruits3 = fruits[:] print(fruits3) fruits4 = fruits[-3:-1] print(fruits4) # 可以通过反向切片操作来获得倒转后的列表的拷贝 fruits5 = fruits[::-1] print(fruits5)if __name__ == &apos;__main__&apos;: main() sorted sort 与 sorted 区别： sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。 list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。 1234567891011121314151617181920212223242526&quot;&quot;&quot;cmp – 可选参数, 如果指定了该参数会使用该参数的方法进行排序。key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。reverse – 排序规则，reverse = True 降序， reverse = False 升序（默认&quot;&quot;&quot;def main(): list1 = [&apos;orange&apos;, &apos;apple&apos;, &apos;zoo&apos;, &apos;internationalization&apos;, &apos;blueberry&apos;] list2 = sorted(list1) # sorted函数返回列表排序后的拷贝不会修改传入的列表 # 函数的设计就应该像sorted函数一样尽可能不产生副作用 list3 = sorted(list1, reverse=True) # 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序 list4 = sorted(list1, key=len) print(list1) print(list2) print(list3) print(list4) # 给列表对象发出排序消息直接在列表对象上进行排序 list1.sort(reverse=True) print(list1) list1.sort(reverse=False) print(list1)if __name__ == &apos;__main__&apos;: main() 元组 使用元组 Python 的元组与列表类似，不同之处在于元组的元素不能修改，在前面的代码中我们已经不止一次使用过元组了。顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组。 123456789101112131415161718192021222324252627282930def main(): # 定义元组 t = (&apos;骆昊&apos;, 38, True, &apos;四川成都&apos;) print(t) # 获取元组中的元素 print(t[0]) print(t[3]) # 遍历元组中的值 for member in t: print(member) # 重新给元组赋值 # t[0] = &apos;王大锤&apos; # TypeError # 变量t重新引用了新的元组原来的元组将被垃圾回收 t = (&apos;王大锤&apos;, 20, True, &apos;云南昆明&apos;) print(t) # 将元组转换成列表 person = list(t) print(person) # 列表是可以修改它的元素的 person[0] = &apos;李小龙&apos; person[1] = 25 print(person) # 将列表转换成元组 fruits_list = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;] fruits_tuple = tuple(fruits_list) print(fruits_tuple)if __name__ == &apos;__main__&apos;: main() 这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？ 元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。 元组在创建时间和占用的空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在ipython中使用魔法指令%timeit来分析创建同样内容的元组和列表所花费的时间，下图是我的macOS系统上测试的结果。 集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def main(): set1 = &#123;1, 2, 3, 3, 3, 2&#125; print(set1) print(&apos;Length =&apos;, len(set1)) set2 = set(range(1, 10)) print(set2) set1.add(4) set1.add(5) set2.update([11, 12]) print(&apos;set1 = &apos;,set1) print(&apos;set2 = &apos;,set2) set2.discard(5) # remove的元素如果不存在会引发KeyError if 4 in set2: set2.remove(4) print(set2) # 遍历集合容器 for elem in set2: print(elem ** 2, end=&apos; &apos;) print() # 将元组转换成集合 set3 = set((1, 2, 3, 3, 2, 1)) print(set3.pop()) print(set3) print(&apos;set1 = &apos;,set1) print(&apos;set2 = &apos;,set2) # 集合的交集、并集、差集、对称差运算 print(set1 &amp; set2) # print(set1.intersection(set2)) print(set1 | set2) # print(set1.union(set2)) print(set1 - set2) # print(set1.difference(set2)) print(set1 ^ set2) # print(set1.symmetric_difference(set2)) print(&apos;set1 = &apos;,set1) print(&apos;set2 = &apos;,set2) print(&apos;set3 = &apos;,set3) # 判断子集和超集 print(set2 &lt;= set1) # print(set2.issubset(set1)) print(set3 &lt;= set1) # print(set3.issubset(set1)) print(set1 &gt;= set2) # print(set1.issuperset(set2)) print(set1 &gt;= set3) # print(set1.issuperset(set3))if __name__ == &apos;__main__&apos;: main() 字典 123456789101112131415161718192021222324252627282930def main(): scores = &#123;&apos;骆昊&apos;: 95, &apos;白元芳&apos;: 78, &apos;狄仁杰&apos;: 82&#125; # 通过键可以获取字典中对应的值 print(scores[&apos;骆昊&apos;]) print(scores[&apos;狄仁杰&apos;]) # 对字典进行遍历(遍历的其实是键再通过键取对应的值) for elem in scores: print(&apos;%s\t---&gt;\t%d&apos; % (elem, scores[elem])) # 更新字典中的元素 scores[&apos;白元芳&apos;] = 65 scores[&apos;诸葛王朗&apos;] = 71 scores.update(冷面=67, 方启鹤=85, 武则天=100) print(scores) if &apos;武则天&apos; in scores: print(scores[&apos;武则天&apos;]) print(scores.get(&apos;武则天&apos;)) # get方法也是通过键获取对应的值但是可以设置默认值 print(scores.get(&apos;武则天&apos;, 60)) # 删除字典中的元素 print(scores.popitem()) print(scores.popitem()) print(scores.pop(&apos;骆昊&apos;, 100)) # 清空字典 scores.clear() print(scores)if __name__ == &apos;__main__&apos;: main() 双色球 random.sample随机取样 12345678910111213141516171819202122232425262728293031323334from random import randrange, randint, sampledef display(balls): &quot;&quot;&quot; 输出列表中的双色球号码 &quot;&quot;&quot; for index, ball in enumerate(balls): if index == len(balls) - 1: print(&apos;|&apos;, end=&apos; &apos;) print(&apos;%02d&apos; % ball, end=&apos; &apos;) print()def random_select(): &quot;&quot;&quot; 随机选择一组号码 &quot;&quot;&quot; red_balls = [x for x in range(1, 34)] selected_balls = [] selected_balls = sample(red_balls, 6) selected_balls.sort() selected_balls.append(randint(1, 16)) return selected_ballsdef main(): n = int(input(&apos;机选几注: &apos;)) for _ in range(n): display(random_select())if __name__ == &apos;__main__&apos;: main() 杨辉三角 12345678910111213141516def main(): num = int(input(&apos;Number of rows: &apos;)) yh = [[]] * num for row in range(len(yh)): yh[row] = [None] * (row + 1) for col in range(len(yh[row])): if col == 0 or col == row: yh[row][col] = 1 else: yh[row][col] = yh[row - 1][col] + yh[row - 1][col - 1] print(yh[row][col], end=&apos;\t&apos;) print()if __name__ == &apos;__main__&apos;: main() 跑马灯 1234567891011121314151617import osimport timedef main(): content = &apos;北京欢迎你为你开天辟地…………&apos; while True: # 清理屏幕上的输出 os.system(&apos;cls&apos;) # os.system(&apos;clear&apos;) print(content) # 休眠200毫秒 time.sleep(0.2) content = content[1:] + content[0]if __name__ == &apos;__main__&apos;: main() 1234567891011121314151617181920212223242526272829303132333435363738def is_leap_year(year): &quot;&quot;&quot; 判断指定的年份是不是闰年 :param year: 年份 :return: 闰年返回True平年返回False &quot;&quot;&quot; return year % 4 == 0 and year % 100 != 0 or year % 400 == 0def which_day(year, month, date): &quot;&quot;&quot; 计算传入的日期是这一年的第几天 :param year: 年 :param month: 月 :param date: 日 :return: 第几天 &quot;&quot;&quot; days_of_month = [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] ][is_leap_year(year)] total = 0 for index in range(month - 1): total += days_of_month[index] return total + datedef main(): print(&apos;这一年的第%d天&apos;%which_day(1980, 11, 28)) print(&apos;这一年的第%d天&apos;%which_day(1981, 12, 31)) print(&apos;这一年的第%d天&apos;%which_day(2018, 1, 1)) print(&apos;这一年的第%d天&apos;%which_day(2016, 3, 1))if __name__ == &apos;__main__&apos;: main() 约瑟夫环 123456789101112131415161718192021222324252627&quot;&quot;&quot;《幸运的基督徒》有15个基督徒和15个非基督徒在海上遇险，为了能让一部分人活下来不得不将其中15个人扔到海里面去，有个人想了个办法就是大家围成一个圈，由某个人开始从1报数，报到9的人就扔到海里面，他后面的人接着从1开始报数，报到9的人继续扔到海里面，直到扔掉15个人。由于上帝的保佑，15个基督徒都幸免于难，问这些人最开始是怎么站的，哪些位置是基督徒哪些位置是非基督徒。&quot;&quot;&quot;def main(): persons = [True] * 30 counter, index, number = 0, 0, 0 while counter &lt; 15: if persons[index]: number += 1 if number == 9: persons[index] = False counter += 1 number = 0 index += 1 index %= 30 for person in persons: print(&apos;基&apos; if person else &apos;非&apos;, end=&apos;&apos;)if __name__ == &apos;__main__&apos;: main() 验证码 12345678910111213141516171819202122232425262728293031import randomdef generate_code(code_len=4): &quot;&quot;&quot; 生成指定长度的验证码 :param code_len: 验证码的长度(默认4个字符) :return: 由大小写英文字母和数字构成的随机验证码 &quot;&quot;&quot; all_chars = &apos;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos; last_pos = len(all_chars) - 1 code = &apos;&apos; for _ in range(code_len): index = random.randint(0, last_pos) code += all_chars[index] return codedef main(): stl1 = generate_code() print(&apos;验证码为：%a&apos; % stl1) yz = input(&apos;请输入验证码:&apos;) if yz == stl1: print(&apos;验证码正确！&apos;) else: print(&apos;验证码错误！！&apos;)if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
