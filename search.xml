<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F11%2F23%2FSX-Day1%2F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%2Cmd%2F</url>
    <content type="text"><![CDATA[运行环境1spring.profiles.active=prod/dev]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2F2019%2F11%2F16%2FSpring%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SX-Day1]]></title>
    <url>%2F2019%2F11%2F15%2FSX-Day1%2F</url>
    <content type="text"><![CDATA[SVNTortoiseSVNTortoiseSVN 是 Subversion 版本控制系统的一个免费开源客户端，可以超越时间的管理文件和目录。 Maven12345678910&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; &lt;localRepository&gt;E:\tools\repository&lt;/localRepository&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!-- mirrors | This is a list of mirrors to be used in downloading artifacts from remote repositories. | | It works like this: a POM may declare a repository to use in resolving certain artifacts. | However, this repository may have problems with heavy traffic at times, so people have mirrored | it to several places. | | That repository definition will have a unique id, so we can create a mirror reference for that | repository, to be used as an alternate download site. The mirror site will be the preferred | server for that repository. |--&gt;&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;!-- 阿里云仓库 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库1 --&gt; &lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库2 --&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;profiles&gt; &lt;!-- profile | Specifies a set of introductions to the build process, to be activated using one or more of the | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt; | or the command line, profiles have to have an ID that is unique. | | An encouraged best practice for profile identification is to use a consistent naming convention | for profiles, such as &apos;env-dev&apos;, &apos;env-test&apos;, &apos;env-production&apos;, &apos;user-jdcasey&apos;, &apos;user-brett&apos;, etc. | This will make it more intuitive to understand what the set of introduced profiles is attempting | to accomplish, particularly when you only have a list of profile id&apos;s for debug. | | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo. &lt;profile&gt; &lt;id&gt;jdk-1.4&lt;/id&gt; &lt;activation&gt; &lt;jdk&gt;1.4&lt;/jdk&gt; &lt;/activation&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jdk14&lt;/id&gt; &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt; &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; --&gt; &lt;profile&gt; &lt;id&gt;JDK-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; redisIDEAlombok插件学习计划Spring Boot微服务]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQL]]></title>
    <url>%2F2019%2F11%2F10%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%2F%E2%80%9CSQL%E2%80%9D%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2019%2F11%2F10%2F%E7%AE%97%E6%B3%95%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[两数之和方法一123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for(int i=0;i&lt;nums.length;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums [j] == target - nums[i])&#123; return new int[] &#123;i,j&#125;; &#125; &#125; &#125; throw new IllegalArgumentException(&quot;No&quot;); &#125;&#125; 方法二1234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库原理]]></title>
    <url>%2F2019%2F11%2F10%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[事务事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。 ACID 原子性（Atomicity）事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。 回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。 一致性（Consistency）数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。 隔离性（Isolation）一个事务所做的修改在最终提交以前，对其它事务是不可见的。 持久性（Durability）一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。 使用重做日志来保证持久性。 事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系： 只有满足一致性，事务的执行结果才是正确的。在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。事务满足持久化是为了能应对数据库崩溃的情况。 并发一致性问题在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。 丢失修改读脏数据不可重复读幻影读封锁封锁粒度MySQL 中提供了两种封锁粒度：行级锁以及表级锁。 应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。 但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。 在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。 封锁类型1.读写锁 排它锁（Exclusive），简写为 X 锁，又称写锁。 共享锁（Shared），简写为 S 锁，又称读锁。有以下两个规定： 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。 2.意向锁使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。 意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定： 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁； 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。 任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁； 这里的 X/IX/S/IS 锁都是表级锁，IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。） 封锁协议三和封锁协议一级封锁协议事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。 可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。 二级封锁协议在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。 可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。 三级封锁协议在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。 可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常Exception]]></title>
    <url>%2F2019%2F11%2F05%2F%E5%BC%82%E5%B8%B8Exception%2F</url>
    <content type="text"><![CDATA[IllegalArgumentExceptionIllegalArgumentException是非法参数异常，报这个异常说明传入的参数违反了一个方法要求的某些特性。 1throw new IllegalArgumentException(&quot;No&quot;);]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[容器和泛型]]></title>
    <url>%2F2019%2F11%2F02%2FJava%E5%9F%BA%E7%A1%80%2F%E5%AE%B9%E5%99%A8%E5%92%8C%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java容器大致可分为：Set、List、Queue和Map4种，所有的容器类都位于java.util包下，其中的接口及类之间的关系如图1.1所示（实线表示继承，虚线表示实现接口）。 方 法 描 述 boolean add(E e) 向容器中添加一个元素boolean addAll(Collection c) 向容器中添加参数中所有的元素 void clear() 移除容器中的所有元素 boolean contains(Object o) 判定此 collection 是否包含指定的元素，有则返回 true boolean containsAll(Collection c) 判定此 collection 是否包含指定 collection 中的所有元素，是则返回 trueboolean isEmpty() 判定此容器是否为空，是则返回trueIterator iterator() 返回一个Iterator，用来遍历容器中的所有元素boolean remove(Object o) 如果容器中存在此元素，则删除它Boolean removeAll(Collection c) 删除容器c里包含的所有元素，成功删除一个（或以上）元素则返回true boolean retainAll(Collection c) 将此Collection与参数c的交集存入此Collection中int size() 返回此 collection 中的元素数目Object[] toArray() 返回包含此 collection 中所有元素的数组 Collections实用类ListList代表长度可变的线性表，Collections的以下方法适用于List类型。 copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)：将所有元素从一个列表复制到另一个列表。 fill(List&lt;? super T&gt; list, T obj)：使用指定元素替换指定列表中的所有元素。 nCopies(int n, T o)：返回由指定对象的n个副本组成的不可修改的列表。 shuffle(List&lt;?&gt; list)：使用默认随机源对指定列表进行置换。 sort(List list)：根据元素的自然顺序对指定列表按升序排序。 Comparator接口排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package org.container; import java.util.*; class Employee implements Comparable &#123; private String name; private int salary; public Employee(String name, int age) &#123; this.name = name; this.salary = age; &#125; public String toString() &#123; return &quot;name=&quot; + name + &quot;, &quot; + &quot;salary=&quot; + salary; &#125; public boolean equals(Object o) &#123; // 重写equals()方法 if (!(o instanceof Employee)) return false; Employee employee = (Employee) o; if (this.name.equals(employee.name) &amp;&amp; this.salary ==employee.salary) return true; else return false; &#125; public int hashCode() &#123; // 重写hashCode()方法 int result; result = (name == null ? 0 : name.hashCode()); return result; &#125; public int compareTo(Object o) &#123; // 重写compareTo()方法 Employee e = (Employee) o; int result = salary &gt; e.salary ? 1 : (salary == e.salary ? 0 : -1); if (0 == result) &#123; result = name.compareTo(e.name); &#125; return result; &#125; public static void main(String[] args) &#123; Set&lt;Employee&gt; set = new TreeSet&lt;Employee&gt;(); set.add(new Employee(&quot;Lucy&quot;, 2800)); set.add(new Employee(&quot;John&quot;, 4000)); set.add(new Employee(&quot;Mary&quot;, 3000)); set.add(new Employee(&quot;Lily&quot;, 3000)); Iterator&lt;Employee&gt; it = set.iterator(); while (it.hasNext()) &#123; Employee student = it.next(); System.out.println(student); &#125; &#125; &#125; List（列表）ArrayList代表长度可变的数组，允许对元素进行随机的快速访问，但是向ArrayList中插入与删除元素的速度较慢。ArrayList是线程不安全的，若要成为线程安全的，可用： 1List list = Collections.synchronizedList(new ArrayList()); 栈的实现“栈”是后进先出（先进的则后出）的容器，因LinkedList本身具有能实现栈功能的方法，可以直接将其作为栈来使用。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2019%2F10%2F27%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树特点由二叉树定义以及图示分析得出二叉树有以下特点：1）每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。2）左子树和右子树是有顺序的，次序不能任意颠倒。3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。 二叉树性质1）在二叉树的第i层上最多有2i-1 个节点 。（i&gt;=1）2）二叉树中如果深度为k,那么最多有2k-1个节点。(k&gt;=1）3）n0=n2+1 n0表示度数为0的节点数，n2表示度数为2的节点数。4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。5）若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：(1) 若 i=1，则该结点是二叉树的根，无双亲,当i &gt; 0时，该结点的双亲结点为[(i-1)/2];(2) 若 2i+1&lt;n，则其左孩子存在并且编号为2i+1， 否则无左孩子结点；(3) 若 2(i+1)&lt;n，则其右孩子存在并且编号为2（i+1）， 否则无右孩子结点。 遍历前，中，后只是指父节点遍历的顺序 前序就是 父节点-&gt;左子树-&gt;右子树 中序是 左子树-&gt;父节点-&gt;右子树 后序是 左子树 -&gt; 右子树 -&gt;父节点 树的定义123456789public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; 递归方法直观的方法是通过递归来解决问题。在这里，我们演示了 DFS（深度优先搜索）策略的示例。 1234567891011class Solution &#123; public int maxDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; else &#123; int left_height = maxDepth(root.left); int right_height = maxDepth(root.right); return java.lang.Math.max(left_height, right_height) + 1; &#125; &#125;&#125; 时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)O(N)，其中 NN 是结点的数量。 空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 NN 次（树的高度），因此保持调用栈的存储将是 O(N)O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 \log(N)log(N)。因此，在这种情况下的空间复杂度将是 O(\log(N))O(log(N))。 迭代我们还可以在栈的帮助下将上面的递归转换为迭代。 我们的想法是使用 DFS 策略访问每个结点，同时在每次访问时更新最大深度。 所以我们从包含根结点且相应深度为 1 的栈开始。然后我们继续迭代：将当前结点弹出栈并推入子结点。每一步都会更新深度。 12345678910111213141516171819202122232425JavaPythonimport javafx.util.Pair;import java.lang.Math;class Solution &#123; public int maxDepth(TreeNode root) &#123; Queue&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;(); if (root != null) &#123; stack.add(new Pair(root, 1)); &#125; int depth = 0; while (!stack.isEmpty()) &#123; Pair&lt;TreeNode, Integer&gt; current = stack.poll(); root = current.getKey(); int current_depth = current.getValue(); if (root != null) &#123; depth = Math.max(depth, current_depth); stack.add(new Pair(root.left, current_depth + 1)); stack.add(new Pair(root.right, current_depth + 1)); &#125; &#125; return depth; &#125;&#125;; 复杂度分析 时间复杂度：O(N)O(N)。 空间复杂度：O(N)O(N)。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[枚举]]></title>
    <url>%2F2019%2F10%2F25%2FJava%E5%9F%BA%E7%A1%80%2F%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[定义枚举Java SE 5.0引入一个新的关键字enum表示枚举类型。定义一个枚举类型很简单，下面是一个枚举类型的示例。 123public enum Season &#123; SPRING, SUMMER, AUTUMN, WINTER;&#125; 上面创建了一个名为Season的枚举类型，它有4个成员。由于枚举类型的实例是常量，因此按命名习惯它们都用大写字母表示。为了使用enum，需要创建一个该类型的引用，并将其赋值给某个实例。例如： 1Season season = season.SUMMER; 枚举方法在创建一个enum的实例后，编译器会自动创建一些有用的方法。ordinal()方法用来返回某个特定enum常量的索引；values()方法用来按照enum常量的声明顺序产生由这些常量值构成的数组。例如： 123for (Season season : Season.values()) &#123; System.out.println(season+&quot;,ordinal &quot;+season.ordinal());&#125; 枚举enum构造方法枚举像类一样也可以有构造方法，这样在定义其成员变量时就可以用构造方法来进行初始化。 在定义枚举时，必须将枚举常量定义在最前面，并以分号“;”与其他成员隔开。 若enum是public类型且在类外部定义，则文件名必须与enum的名字相同，且文件中不能再定义其他public类型的类。enum的构造方法必须是private，否则出错。12345678910111213141516171819202122Orientation.javapackage org.enums;public enum Orientation &#123; EAST(&quot;shanghai&quot;),SOUTH(&quot;shenzhen&quot;),WEST(&quot;xian&quot;),NORTH(&quot;beijing&quot;); private String city; Orientation(String city) &#123; // enum的构造方法，编译程序自动加上private修饰符 this.city = city; &#125; public String getCity() &#123; // enum的普通方法 return city; &#125; public static void main(String[] args) &#123; Orientation or1 = Orientation.EAST; Orientation or2 = Orientation.SOUTH; Orientation or3 = Orientation.WEST; Orientation or4 = Orientation.NORTH; System.out.println(or1.getCity()); System.out.println(or2.getCity()); System.out.println(or3.getCity()); System.out.println(or4.getCity()); &#125;&#125; EnumMap方法EnumMap是一种特殊的Map，它要求所有的键（Key）都必须来自同一个枚举，该枚举在创建EnumMap时显式或隐式地指定。EnumMap在内部表示为 数组 ，这种表示形式非常紧凑且高效，故可放心地使用enum实例在EnumMap中进行查找。不过，只能将enum实例作为键来调用 put()方法 ，其他操作与使用一般的Map差不多。 12345678910111213141516171819202122232425package test;import java.util.Map;enum Size&#123; Small,Medium,Large;&#125;public class EnumMap &#123; public static void main(String[] args) &#123; /** * 创建一个键类型为枚举Size的空枚举映射，键对象为枚举Size型， * 值对象为Integer型，参数为键类型的Class对象 */ Map&lt;Size,Integer&gt; map = new java.util.EnumMap&lt;Size, Integer&gt;(Size.class); map.put(Size.Small,36); map.put(Size.Medium,40); map.put(Size.Large,42); for (Size size: Size.values())&#123; System.out.println(map.get(size)); &#125; for (int value:map.values())&#123; System.out.println(value); &#125; &#125;&#125; 输出结果 123456364042364042 注解在程序中使用注解的优点有： 提供了一种结构化的、且具有类型检查能力的新途径，以编写更为健壮的代码。 通过使用注解，程序员可以在不改变源程序逻辑的情况下为代码加入元数据。 用于附属文件的自动生成，例如部署描述符或bean信息类。 用于测试、日志、事务语义等代码的生成。 按产生方式和功能的不同，Java程序的注解可分为内置注解、自定义注解和元注解。 内置注解内置注解是指Java语言内部已定义好的注解，可直接使用。Java SE 5.0预定义了3种标准注解（在java.lang包中），如下： @Override：表示当前的方法将重写父类中的方法。如果不小心拼写错误或者签名对不上父类的方法，编译器就会发出错误提示。 @Deprecated：表示某个程序元素（类、方法等）已过时。当其他程序使用已过时的类、方法时，编译器将会发出警告。 @SuppressWarnings：关闭指定的编译器警告信息。 重写@Override123456789101112131415161718192021222324252627282930package test;class Person &#123; String name; int age; Person(String str, int i) &#123; name = str; age = i; &#125; @Override // 重写从Object类继承过来的equals()方法 public boolean equals(Object obj) &#123; Person p = null; if (obj instanceof Person) p = (Person) obj; else return false; if (p.name == this.name &amp;&amp; p.age == this.age) return true; else return false; &#125;&#125;public class OverrideTest &#123; public static void main(String[] args) &#123; Person p1 = new Person(&quot;Tom&quot;, 18); Person p2 = new Person(&quot;Tom&quot;, 18); System.out.println(p1.equals(p2)); &#125;&#125; @Deprecated父类的方法不想用的时候可以用@deprecated取消 12345678910111213141516public class DeprecatedTest extends Service &#123; @Override public void doSomething()&#123; System.out.println(&quot;do something in DeprecateTest class&quot;); &#125; public static void main(String[] args)&#123; DeprecatedTest sub = new DeprecatedTest(); sub.doSomething(); &#125;&#125;class Service&#123; @Deprecated public void doSomething()&#123; System.out.printf(&quot;do something&quot;); &#125;&#125; 但是含有标记@Deprecated的类仍然可以被JVM执行。程序运行结果为： 1do something in DeprecatedTest class SuppreessWarnings@SuppressWarnings用于有选择地关闭编译器对类、方法、成员变量、变量初始化的警告，这类警告并不一定表示程序错误。例如，当使用一个容器类又没有提供它的类型时，编译器将发出“unchecked warning”警告，通常这种情况需要查看引起警告的代码，若它真的错了当然要纠正；但有时代码并无错，又无法避免这种警告，此时@SuppressWarnings就派上用场了，在调用的方法前增加该注解告诉编译器停止对此方法的警告。下面的方法f()中定义了一个ArrayList类，但同时会出现警告信息。 1234public void f() &#123; List list = new ArrayList(); list.add(&quot;hello&quot;);&#125; 警告信息表示List类必须使用泛型才是安全的，为消除警告须将这个方法作如下改写： 1234public void f() &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;hello&quot;);&#125; 但如果实际的程序并无很高的安全需求，如此写法就显得烦冗，可又不想看到警告信息，于是使用@SuppressWarnings注解，如下： 12345@SuppressWarnings (value = &#123;&quot;unchecked&quot;&#125;)public void f() &#123; List list = new ArrayList(); list.add(&quot;hello&quot;);&#125; 与@Override和@Deprecated注解不同，@SuppressWarnings有一个类型为String[]的元素。注解的语法允许在注解名后跟括号，括号中是使用逗号分隔的“name = value”对，用来为注解的成员赋值。按照约定，单一元素（只有一个元素）的名字建议取为“value”，而这里@SuppressWarnings类型只定义了一个单一成员，故只有一个简单的“value = {…}”作为“name = value”对，这种情况还可更进一步省去“value =”，例如： 1@SuppressWarnings(&#123;&quot;unchecked&quot;,&quot;deprecation&quot;&#125;) 由于成员值是一个数组，故使用大括号来声明数组值。当@SuppressWarnings所声明的被禁止警告个数为1时，还可省去大括号，如下： 1@SuppressWarnings(&quot;unchecked&quot;) 1234567891011public class SuppressWarningTest &#123; @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) &#123; Map map = new TreeMap(); map.put(&quot;hello&quot;, LocalDateTime.now()); System.out.println(map.get(&quot;hello&quot;)); List list = new ArrayList(); list.add(&quot;annotation&quot;); System.out.println(list); &#125;&#125; 自定义注解注解类型的定义可看作是一种特殊的接口定义，只是在interface关键字前加了一个@符号。编译器在编译注解的定义时，会自动从java.lang.annotation.Annotation接口继承该注解，故不必（也不允许）在注解定义语句后边再加extends子句。可以按如下方式使用自定义的注解MyAnnotation： 12@MyAnnotation(id = 12, value = &quot;java&quot;) public void f() &#123; … &#125; 元注解Java 8在java.lang.annotation包下提供了6个元注解，具体如下。 @Target：指定被修饰的注解能用于哪些程序元素类型。其参数ElementType表示所适用的元素类型，取值有：CONSTRUCTOR（构造器）、FIELD（成员变量）、LOCAL_VARIABLE（局部变量）、METHOD（方法）、PACKAGE（包）、PARAMETER（参数）、TYPE（类、接口、注解类型或枚举），以及ANNOTATION_TYPE（标准注解）。 @Retention：指定被修饰注解的保存级别。其参数RetentionPolicy表示保存级别，取值有：SOURCE（只保留在源代码中，编译器直接丢弃这种注解）、CLASS（保存在class文件中，但运行时JVM不可获取注解信息）、RUNTIME（保存在class文件中且运行时JVM也可获取注解信息），默认保存级别为CLASS。 @Documented：指定被修饰的注解将被javadoc工具提取成文档。 @Inherited：指定被修饰的注解（这里假设为@Xxx）具有继承性，即如果某个类使用了@Xxx注解，则其子类也将自动被@Xxx修饰。 @Repeatable：用于定义Java 8新增的重复注解。 1．@Target@Target描述了被修饰注解所适用的程序元素的种类。当一个注解没有被@Target修饰时可适用于所有的程序元素；而当存在@Target时编译器会强制实施指定的类型限制。例如： 1234567@Target(ElementType.METHOD) @interface MyAnnotation &#123;&#125;@MyAnnotation // 不正确，不能为类注解public class Comment &#123; @MyAnnotation // 正确，可以为方法注解 public void method()&#125; 2．@Retention@Retention定义了注解信息被保留的时间长短，支持三种不同保存级别，写法如下： 123456/* 只保留在源代码中，被编译器丢弃 */@Retention(RetentionPolicy.SOURCE) @interface MyAnnotation1 &#123;&#125;/* 保存在class文件中，但JVM无法获取 */@Retention(RetentionPolicy.CLASS) @interface MyAnnotation2 &#123;&#125;/* 保存在class文件中，且JVM可以获取 */@Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation3 &#123;&#125; 3．@Documented@Documented注解和它的名字一样与文档有关。在默认情况下使用javadoc或其他类似工具自动生成文档时，源程序中的注解将被忽略掉。如果想在文档中也包含注解，就必须使用@Documented修饰想要包含的注解。 4．@Inherited@Inherited表示注解类型会被自动继承。当一个使用@Inherited修饰的注解被用于一个类时，它也将被自动地用于该类的所有子类。例如： 12345@Inherited @interface MyAnnotation &#123;&#125;@MyAnnotationpublic class ParentClass &#123;&#125;public class ChildClass extends ParentClass &#123;&#125; 在以上代码中，ChildClass和ParentClass一样都已被MyAnnotation注解了。 Lambda表达式 新的语法元素和操作符 “–&gt;”，也叫lambda操作符或箭头操作符它分为两个部分：左边指定lambda表达式需要的所有参数，右边指定lambda体，即lambda表达式要执行的动作。Java 8 指定两种lambda体，一种只包含单独一个表达式，一种包含一个代码块。 首先看一个最简单的lambda表达式，它的计算结果是一个常量值，如下： 1()-&gt;274.83 这个lambda表达式没有参数，所以参数列表为空，它返回常量值274.83。因此，这个表达式的作用类似于下面的方法： 1double myVal() &#123; return 274.83; &#125; 当然，lambda表达式定义的方法没有名称。当lambda表达式需要参数时，就要在操作符左侧的参数列表中加以指定。下面是一个简单的例子： 1(value)-&gt;(value % 2) == 0 如果参数value的值是偶数，这个lambda表达式会返回true。 函数式接口(1）定义和使用函数式接口定义函数式接口只能为其声明一个方法，例如： 123public interface MyVal &#123; double getValue();&#125; 其中，getValue()方法隐式地是抽象方法且是MyVal定义的唯一方法。 下面通过一个例子来说明如何在参数上下文中使用lambda表达式。首先，声明对函数式接口MyVal的一个引用： 1MyVal myVal; 接下来，将一个lambda表达式赋给该引用： 1myVal = ()-&gt;274.83; 当目标类型上下文中出现lambda表达式时，会自动创建实现了函数式接口的一个类的实例，函数式接口声明的抽象方法的行为由lambda表达式定义。当通过目标调用该方法时就会执行lambda表达式。可见，lambda表达式提供了一种将代码段转换为对象的方式。上例中的lambda表达式成了getValue()方法的实现。因此，下面的代码执行将显示274.83： 1System.out.println(myVal.getValue()); 使用lambda表达式实现自定义函数式接口。 123456MyIntPredicate.javapackage org.lambda;@FunctionalInterface // Java 8新增注解，指定检查该接口必须是函数式接口public interface MyIntPredicate &#123; // 自定义的函数式接口 boolean test(int value); // 唯一（只能有一个！）的抽象方法&#125; 12345678910package org.lambda;public class LambdaDemo &#123; public static void main(String[] args) &#123; int n = Integer.parseInt(args[0]); MyIntPredicate isEven = (value)-&gt;(value % 2) == 0; // 用lambda表达式实现接口 if(isEven.test(n)) // 调用接口方法返回值判断奇偶数 System.out.println(n + &quot;是偶数&quot;); else System.out.println(n + &quot;是奇数&quot;); &#125; （2）使用Java 8预定义的接口Java 8在java.util.function包下预定义了大量函数式接口，典型地包含如下4类。 XxxFunction：这类接口中通常包含一个apply()抽象方法对参数进行处理、转换（apply()方法的处理逻辑由lambda表达式来实现），然后返回一个值。 XxxConsumer：这类接口中通常包含一个accept()抽象方法，它与XxxFunction接口的apply()方法基本相似，也负责对参数进行处理，只是该方法不会返回处理的结果。 XxxxPredicate：这类接口中通常包含一个test()抽象方法，该方法用来对参数进行某种判断（其判断逻辑也由lambda表达式实现），然后返回一个boolean值。 XxxSupplier：这类接口中通常包含一个getAsXxx()抽象方法，此方法不需要输入参数，它会按某种逻辑算法（算法当然也是lambda表达式实现的）返回一个数据。 用Java 8预定义的函数式接口实现奇偶数判断。FuncInterfaceDemo.java 123456789101112package org.lambda;import java.util.function.*; // 导入包含预定义接口的包public class FuncInterfaceDemo &#123; public static void main(String[] args) &#123; int n = Integer.parseInt(args[0]); IntPredicate isEven = (value)-&gt;(value % 2) == 0; // lambda表达式实现预定义接口 if(isEven.test(n)) System.out.println(n + &quot;是偶数&quot;); else System.out.println(n + &quot;是奇数&quot;); &#125;&#125; Lambda表达式与匿名内部类方法引用用lambda表达式引用StringBuffer类中的方法，实现字符串反序输出。 12345MyStrBufFunction.javapackage org.lambda;public interface MyStrBufFunction &#123; // 定义函数式接口 StringBuffer reverse(StringBuffer str); // 抽象方法（用于字符串反转的功能）&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>enum</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery]]></title>
    <url>%2F2019%2F10%2F22%2FJQuery%2F</url>
    <content type="text"><![CDATA[Jquery简介jQuery 是一个 JavaScript 库。jQuery 极大地简化了 JavaScript 编程。jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库(或JavaScript框架)。jQuery设计的宗旨是”write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 jQuery的核心特性可以总结为:具有独特的链式语法和短小清晰的多功能接口;具有高效灵活的css选择器，并且可对CSS选择器进行扩展;拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等。 工作原理jQuery的模块可以分为3部分: 入口模块、底层支持模块和功能模块。 在构造jQuery对象模块中，如果在调用构造函数jQuery()创建jQuery对象时传入了选择器表达式，则会调用选择器Sizzle(一款纯JavaScript实现的CSS选择器引擎，用于查找与选择器表达式匹配的元素集合)遍历文档，查找与之匹配的DOM元素，并创建一个包含了这些DOM元素引用的jQuery对象。 浏览器功能测试模块提供了针对不同浏览器功能和bug的测试结果，其他模块则基于这些测试结果来解决浏览器之间的兼容性问题。 在底层支持模块中，回调函数列表模块用于增强对回调函数的管理，支持添加、移除、触发、锁定、禁用回调函数等功能;异步队列模块用于解耦异步任务和回调函数，它在回调函数列表的基础上为回调函数增加了状态，并提供了多个回调函数列表，支持传播任意同步或异步回调函数的成功或失败状态;数据缓存模块用于为DOM元素和Javascript对象附加任意类型的数据;队列模块用于管理一组函数，支持函数的入队和出队操作，并确保函数按顺序执行，它基于数据缓存模块实现。 在功能模块中，事件系统提供了统一的事件绑定、响应、手动触发和移除机制，它并没有将事件直接绑定到DOM元素上，而是基于数据缓存模块来管理事件;Ajax模块允许从服务器上加载数据，而不用刷新页面，它基于异步队列模块来管理和触发回调函数;动画模块用于向网页中添加动画效果，它基于队列模块来管理和执行动画函数;属性操作模块用于对HTML属性和DOM属性进行读取、设置和移除操作;DOM遍历模块用于在DoM树中遍历父元素、子元素和兄弟元素;DOM操作模块用于插入、移除、复制和替换DOM元素;样式操作模块用于获取计算样式或设置内联样式;坐标模块用于读取或设置DOM元素的文档坐标;尺寸模块用于获取DOM元素的高度和宽度。 语言基础选择器jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。 jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”(或选择)HTML 元素。 它基于已经存在的CSS 选择器，除此之外，它还有一些自定义的选择器。 jQuery 中所有选择器都以美元符号开头:$()。 元素选择器 jQuery 元素选择器基于元素名选取元素。 在页面中选取所有 元素 id 选择器 jQuery #id 选择器通过 HTML 元素的 id 属性选取指定的元素。 页面中元素的 id 应该是唯一的，所以您要在页面中选取唯一的元素需要通过 #id 选择器。 通过 id 选取元素语法如下: class 选择器 jQuery 类选择器可以通过指定的 class 查找元素。 事件处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061$(document).ready()$(document).ready() 方法允许我们在文档完全加载完后执行函数。该事件方法在jQuery 语法章节中已经提到过。click()click() 方法是当按钮点击事件被触发时会调用一个函数。该函数在用户点击 HTML 元素时执行。在下面的实例中，当点击事件在某个 &lt;p&gt; 元素上触发时，隐藏当前的 &lt;p&gt; 元素:dblclick()当双击元素时，会发生 dblclick 事件。dblclick() 方法触发 dblclick 事件，或规定当发生 dblclick 事件时运行的函数:mouseenter()当鼠标指针穿过元素时，会发生 mouseenter 事件。mouseenter() 方法触发 mouseenter 事件，或规定当发生 mouseenter 事件时运行的函数。mouseleave()当鼠标指针离开元素时，会发生 mouseleave 事件。mouseleave() 方法触发 mouseleave 事件，或规定当发生 mouseleave 事件时运行的函数:mousedown()当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。mousedown() 方法触发 mousedown 事件，或规定当发生 mousedown 事件时运行的函数:mouseup()当在元素上松开鼠标按钮时，会发生 mouseup 事件。方法触发 mouseup 事件，或规定当发生 mouseup 事件时运行的函数:hover()hover()方法用于模拟光标悬停事件。当鼠标移动到元素上时，会触发指定的第一个函数(mouseenter);当鼠标移出这个元素时，会触发指定的第二个函数(mouseleave)。focus()当元素获得焦点时，发生focus事件。当通过鼠标点击选中元素或通过tab键定位到元素时，该元素就会获得焦点。focus()方法触发 focus 事件，或规定当发生focus事件时运行的函数。blur()当元素失去焦点时，发生 blur 事件。blur() 方法触发 blur 事件，或规定当发生 blur 事件时运行的函数:]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo绑定域名]]></title>
    <url>%2F2019%2F10%2F22%2Fhexo%2F%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[hexo域名绑定在hexo blog绑定在github时候，每一次提交生成的静态文件时候，都会重置我在GitHub绑定的自定义域名，后面看了网上资料发现是没有写CNAME文件 创建CNAME文件在hexo/source文件夹下创建一个CAME文件 12# 你的自定义域名www.python365.club 使用 hexo g -d 上上传就不用再去GitHub更新自定义域名了。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用类]]></title>
    <url>%2F2019%2F10%2F21%2FJava%E5%9F%BA%E7%A1%80%2FJava%E5%B8%B8%E7%94%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Object类equals()方法hashCode()方法toString()方法字符串类String类StringBuffer类包装类Math类Random类日期时间类正则表达式数组实用类]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2019%2F10%2F19%2FJava%E5%9F%BA%E7%A1%80%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[extendssuper 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super 函数。 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。多态抽象类和接口只声明不提供方法的抽象方法：1abstract &lt;返回值类型&gt; &lt;方法名&gt; ([&lt;形参列表&gt;]); 用abstract修饰的是抽象类 123[访问修饰符] abstract class [类名]&#123; ...&#125; 抽象类特性]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置SSH使用hexo deploy时免输用户名和密码]]></title>
    <url>%2F2019%2F10%2F18%2Fhexo%2F%E8%AE%BE%E7%BD%AESSH%E4%BD%BF%E7%94%A8hexo-deploy%E6%97%B6%E5%85%8D%E8%BE%93%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[生成SSH秘钥打开命令行工具，任意位置打开 Git Bash Here 然后输入以下命令 1$ cd ~/.ssh 使用 ssh-keygen 生成密钥1234$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;# Creates a new ssh key using the provided emailGenerating public/private rsa key pair.Enter file in which to save the key (/home/you/.ssh/id_rsa): 使用默认的文件名直接enter，接下来显示如下 12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 按提示输入密码即可（简化流程的话在键入命令ssh-keygen -t rsa -C “your_email@example.com“ 以后的三次提示输入都可以直接回车跳过）。 密钥生成成功 1234Your identification has been saved in /home/you/.ssh/id_rsa.Your public key has been saved in /home/you/.ssh/id_rsa.pub.The key fingerprint is:…………………此处是密钥内容…………………… your_email@example.com 设置Github 项目的 Deploy keys可以选择是在用户设置中添加密钥（Settings –&gt; SSH GPG keys）还是单个项目中添加密钥，在这里我就在我们的博客项目中添加密钥，此处以我的博客为例。在 caser04255.github.io 的首页菜单栏中点击 Settings –&gt; Deploy keys –&gt; Add deploy key，然后将生成的 id_rsa.pub 中的内容全选复制到 key 输入框中，然后点击 Add key 完成添加公钥。 接下来测试配置是否成功 1ssh -T git@github.com 如果出现以下内容即表示配置完成并且成功！ 12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 设置博客提交地址hexo 的配置文件 _config.yml 中的deploy 属性。12345deploy: type: git repo: git@github.com:caser0425/caser0425.github.io.git branch: master message: 将repo改成 git@github.com:username/username.github.io.git 就可以了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类与对象]]></title>
    <url>%2F2019%2F10%2F18%2FJava%E5%9F%BA%E7%A1%80%2FJava%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类类的定义Java中类的定义基本格式： 123[类修饰符] class &lt;类名&gt;&#123; &lt;类体&gt;&#125; 类修饰符用public或默认 类名第一个字母要大写 类体可缺省 类体由变量定义和方法定义组成 类的成员变量声明格式： 12[修饰符] &lt;类型&gt; &lt;变量名&gt; [=初始值];private String name = &quot;Tom&quot;; 类的成员方法声明格式： 123[修饰符] &lt;返回值&gt;&lt; 方法名&gt; (形参列表)&#123; &lt;方法体&gt;&#125; 变量初始化 成员变量未初始化会使用默认的初始化值 类的方法方法定义方法定义的格式 123[修饰符] &lt;返回值类型&gt; &lt;方法名&gt; [&lt;形式参数列表&gt;]&#123; &lt;方法体&gt;&#125; 返回值可以是任意类型 如果没有返回值，类型定义为 void &lt;形式参数列表&gt;是该方法接收的输入值和相应类型 方法体可以缺省 参数传递Java规定所有参数传递都为“值传递”。机制是：首先从左到右计算各个实参的值，然后在运行栈为形参非配空间，再为该方法其他局部参数分配空间，计算的实参的值分配到形参变量空间中。运行完成自动删除该方法所有信息。 递归 直接递归 间接递归 方法重载方法重载是指一个类中可以定义有相同名字，但参数不同的多个方法。各方法之间的参数个数，参数顺序，类型不同不可以构成重载。 123456789void f(int x)&#123; ...&#125;void f(int x,int y)&#123; ...&#125;void f(int x,String s)&#123; ...&#125; 创建对象对象即类的实例化。 构造方法构造方法语法规则 方法必须与类名相同 不用声明返回类型 不能被static、final、synchronized、abstract、和native修饰。 默认构造方法未设置构造方法会自动生成无参构造方法 构造方法重载通过改变方法中的参数来重载，至少要有默认构造方法 this 引用this是Java的关键字，用于表示对象自身的引用。 类的static方法中，是不能使用this的。 this是调用当前对象的值。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2019%2F10%2F18%2FJava%E5%9F%BA%E7%A1%80%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组一维数组定义123456格式1：&lt;类型&gt; &lt;数组名&gt;[];格式2：&lt;类型&gt;[] &lt;数组名&gt;;int a[];String[] person;int b[100];不能在定义时指定长度 创建一维数组对象123数组名 = new 元素类型 [元素个数];int[] Arry = new int[100]; 数组初始化静态初始化1int[] Arry = &#123;1,2,3,4&#125; 动态初始化12345678int a[] = new int[3];a[0]=1; a[1]=5; a[2]=3;引用类型也可初始化Point[] Pa = new Point[3];Pa[0] = new Point(1,2);Pa[1] = new Point(1,4);Pa[2] = new Point(3,9); 多维数组123456格式1：&lt;类型&gt; &lt;数组名&gt;[][];格式2：&lt;类型&gt;[][] &lt;数组名&gt;;int a[][];String[][] person;int b[100][100];不能在定义时指定长度 创建二维数组对象123数组名 = new 元素类型 [元素个数][元素个数];int[][] a = new int[2][3]; 数组初始化静态初始化123String[][] alphabet = &#123;&#123;&quot;a&quot;,&quot;b&quot;.&quot;c&quot;&#125;,&#123;&quot;d&quot;,&quot;f&quot;,&quot;g&quot;&#125;,&#123;&quot;h&quot;,&quot;y&quot;,&quot;z&quot;&#125;&#125;String[4][3] alphabet = &#123;&#123;&quot;a&quot;,&quot;b&quot;.&quot;c&quot;&#125;,&#123;&quot;d&quot;,&quot;f&quot;,&quot;g&quot;&#125;,&#123;&quot;h&quot;,&quot;y&quot;,&quot;z&quot;&#125;&#125;//初始化不可以指定长度 动态初始化1234567方法一int[][] arr = new int[3][4];方法二int[][] c = new int[3][];c[0] = mew int[3];c[1] = mew int[4];c[2] = mew int[5];]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HandlerInterceptor拦截器的使用]]></title>
    <url>%2F2019%2F10%2F12%2FHandlerInterceptor%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[HandlerInterceptor拦截器的使用 HandlerInterceptor简介 拦截器我想大家都并不陌生，最常用的登录拦截、或是权限校验、或是防重复提交、或是根据业务像12306去校验购票时间,总之可以去做很多的事情。 1、定义实现类定义一个Interceptor 非常简单方式也有几种，我这里简单列举两种 1、类要实现Spring 的HandlerInterceptor 接口 2、类继承实现了HandlerInterceptor 接口的类，例如 已经提供的实现了HandlerInterceptor 接口的抽象类HandlerInterceptorAdapter 2、HandlerInterceptor方法介绍12345678910 boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception;void afterCompletion( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception; preHandle：在业务处理器处理请求之前被调用。预处理，可以进行编码、安全控制、权限校验等处理； postHandle：在业务处理器处理请求执行完成后，生成视图之前执行。后处理（调用了Service并返回ModelAndView，但未进行页面渲染），有机会修改ModelAndView ； afterCompletion：在DispatcherServlet完全处理完请求后被调用，可用于清理资源等。返回处理（已经渲染了页面）； 拦截器方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.tdschool.interceptor;import java.util.Random;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import com.tdschool.utils.MUtils;public class TokenInterceptor implements HandlerInterceptor &#123; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception exception) throws Exception &#123; // TODO Auto-generated method stub &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelView) throws Exception &#123; // TODO Auto-generated method stub &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // TODO 判断是否有自定义的注解 if(handler==null||!(handler instanceof HandlerMethod)) return true;// 代表继续执行下一步=》 进入cntroller UserToken token= ((HandlerMethod)handler).getMethodAnnotation(UserToken.class); if(token==null)return true; if(token.create())&#123; // TODO 需要生成token String nostr = MUtils.randomString(32); request.getSession().setAttribute(&quot;tokenvalue&quot;, nostr); &#125;else if(token.check())&#123; // TODO 需要进行token验证 String tokenvalue = (String) request.getSession().getAttribute(&quot;tokenvalue&quot;); String requestToke = request.getParameter(&quot;tokenvalue&quot;); if(tokenvalue!=null&amp;&amp;tokenvalue.equals(requestToke))&#123; // TODO 验证成功 直接进入下一步 &#125;else&#123; // TODO 验证失败 返回错误信息 return false; &#125; &#125; return true; &#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 常用指令]]></title>
    <url>%2F2019%2F09%2F01%2Fhexo%2Fhexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post如果我们要创建一篇文章的话，我们可以通过new命令来创建，也可以直接在博客目录下面的\source_posts里面创建markdown文件。 1$ hexo new "My New Post" 如果标题包含空格的话，请使用引号括起来。 More info: Writing Run server开启服务器，网址为http://localhost:4000 1$ hexo server More info: Server Generate static filesgenerate命令是用来生成静态文件的，在我们发布到GitHub的仓库的时候，需要先生成，才能上传。 1$ hexo generate 可以简写为 1$ hexo g More info: Generating Deploy to remote sites部署网址，上传到我们的GitHub的仓库上面 1$ hexo deploy 可以简写为 1$ hexo d clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果对站点的更改无论如何也不生效，运行该命令。 1hexo clean 一般我们上传到GitHub的时候我们用这条命令来执行，生成静态文件并且部署到服务器。 1hexo g -d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实战]]></title>
    <url>%2F2019%2F08%2F01%2Fpython%2F</url>
    <content type="text"><![CDATA[Python实战 1. 分段函数求值 123456789101112131415&quot;&quot;&quot;&quot; 3x - 5（x&gt; 1）f（x）= x + 2（-1 &lt;= x &lt;= 1） 5x + 3（x &lt;-1）&quot;&quot;&quot;&quot;&quot;x = float(input(&apos;x = &apos;))if x &gt; 1: y = 3 * x - 5elif x &gt;= -1: y = x + 2else: y = 5 * x + 3print(&apos;f(%.2f) = %.2f&apos; % (x,y)) 2. 1-100求和 12345678910111213141516171819&apos;&apos;&apos;&apos;range(101)可以产生一个0到100的整数序列。range(1, 100)可以产生一个1到99的整数序列。range(1, 100, 2)可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;sum = 0for x in range(101): sum += xprint(sum)&apos;&apos;&apos;&quot;1-100偶数求和&quot;sum = 0for x in range(1,101,2): sum += xprint(sum) 3. 猜数字游戏 1234567891011121314151617181920212223&apos;&apos;&apos;计算机出一个1~100之间的随机数由人来猜计算机根据人猜的数字分别给出提示大一点/小一点/猜对了&apos;&apos;&apos;&apos;&apos;import randomanswer = random.randint(1,100)counter = 0while True: counter +=1 number = int(input(&apos;请输入：&apos;)) if number &lt; answer: print(&apos;比它大&apos;) elif number &gt; answer: print(&apos;比它小&apos;) else: print(&apos;你猜对了&apos;) break #break一定要，不然不会跳出循环print(&apos;你总共猜了%d次&apos; % counter)if counter &gt; 7: print(&apos;智商需要充值&apos;) 4. 用户身份验证 123456789101112131415&quot;&quot;&quot;用户身份验证&quot;&quot;&quot;# import getpass# from getpass import getpass# from getpass import *username = input(&apos;请输入用户名: &apos;)password = input(&apos;请输入口令: &apos;)# 输入口令的时候终端中没有回显# password = getpass.getpass(&apos;请输入口令: &apos;)if username == &apos;admin&apos; and password == &apos;123456&apos;: print(&apos;身份验证成功!&apos;)else: print(&apos;身份验证失败!&apos;) 5. 输出乘法口诀表(九九表) 12345678&quot;&quot;&quot;输出乘法口诀表(九九表)&quot;&quot;&quot;&quot;&quot;for i in range(1,10): for j in range(1,i+1): print(&apos;%d * %d = %d&apos;%(i, j, i * j),end=&apos;\t&apos;) print() 6. 输入一个正整数判断它是不是素数 1234567891011121314151617&quot;&quot;&quot;输入一个正整数判断它是不是素数&quot;&quot;&quot;&quot;&quot;from math import sqrtnum = int(input(&apos;请输入一个正整数;&apos;))end = int(sqrt(num))is_prime = Truefor x in range(2, end + 1): if num % x == 0: is_prime = False breakif is_prime and num != 1: print(&apos;%d是素数&apos; % num)else: print(&apos;%d不是素数&apos; % num) 7. 打印各种三角形图案 123456789101112131415161718192021222324252627282930313233343536373839404142434445&quot;&quot;&quot;打印各种三角形图案*************** * ** *** ********* * *** ***** ****************&quot;&quot;&quot;&quot;&quot;row = int(input(&apos;请输入行数: &apos;))for i in range(row): for _ in range(i + 1): print(&apos;*&apos;, end=&apos;&apos;) print()for i in range(row): for j in range(row): if j &lt; row - i - 1: print(&apos; &apos;, end=&apos;&apos;) else: print(&apos;*&apos;, end=&apos;&apos;) print()for i in range(row): for _ in range(row - i - 1): print(&apos; &apos;, end=&apos;&apos;) for _ in range(2 * i + 1): print(&apos;*&apos;, end=&apos;&apos;) print() 8. 求解《百钱百鸡》问题 12345678910&quot;&quot;&quot;求解《百钱百鸡》问题1只公鸡5元 1只母鸡3元 3只小鸡1元 用100元买100只鸡问公鸡 母鸡 小鸡各有多少只&quot;&quot;&quot;&quot;&quot;for x in range(0,20): for y in range(0,33): z = 100 - x - y if x * 5 + y * 3 + z / 3 == 100: print(&apos;%d只公鸡、%d只母鸡、%d只小鸡。&apos;%(x,y,z)) 9. Craps赌博游戏 123456789101112131415161718192021222324252627282930313233343536373839404142434445&quot;&quot;&quot;Craps赌博游戏玩家摇两颗色子 如果第一次摇出7点或11点 玩家胜如果摇出2点 3点 12点 庄家胜 其他情况游戏继续玩家再次要色子 如果摇出7点 庄家胜如果摇出第一次摇的点数 玩家胜否则游戏继续 玩家继续摇色子玩家进入游戏时有1000元的赌注 全部输光游戏结束&quot;&quot;&quot;&quot;&quot;from random import randintmoney = 1000while money &gt; 0 : print(&apos;你的资产为:%d&apos;%money) needs_go_on = False while True: debt = int(input(&apos;请下注：&apos;)) if debt &gt; 0 and debt &lt;= money : break first = randint(1,6) + randint(1,6) print(&apos;玩家摇出了%d点。&apos;% first) if first == 7 or first == 11: print(&apos;玩家胜&apos;) money += debt elif first == 2 or first == 3 or first == 12 : print(&apos;庄家胜&apos;) money -= debt else: needs_go_on =True while needs_go_on : current = randint(1,6) + randint(1,6) print(&apos;玩家摇出来%d点&apos;%current) if current == 7: print(&apos;庄家胜！&apos;) money -= debt needs_go_on = False elif current == first: print(&apos;玩家胜!&apos;) money += debt needs_go_on = Falseprint(&apos;你破产了，游戏结束！&apos;) 10. 输出斐波那契数列的前20个数 1234567891011&quot;&quot;&quot;输出斐波那契数列的前20个数1 1 2 3 5 8 13 21 ...&quot;&quot;&quot;&quot;&quot;a = 0b = 1for _ in range(20): a, b = b, a + b print(a, end=&apos; &apos;) 11. 水仙花数 12345678910111213&quot;&quot;&quot;找出100~999之间的所有水仙花数水仙花数是各位立方和等于这个数本身的数如: 153 = 1**3 + 5**3 + 3**3&quot;&quot;&quot;&quot;&quot;for num in range(100,1000): low = num % 10 mid = num // 10 % 10 high = num //100 if num == low ** 3 + mid ** 3 + high ** 3: print(num) 12. 判断输入的正整数是不是回文数 12345678910111213141516171819&quot;&quot;&quot;判断输入的正整数是不是回文数回文数是指将一个正整数从左往右排列和从右往左排列值一样的数Version: 0.1Author: 骆昊Date: 2018-03-02&quot;&quot;&quot;&quot;&quot;num = int(input(&apos;请输入一个正整数: &apos;))temp = numnum2 = 0while temp &gt; 0: num2 *= 10 num2 += temp % 10 temp //= 10if num == num2: print(&apos;%d是回文数&apos; % num)else: print(&apos;%d不是回文数&apos; % num) 13. 找出1~9999之间的所有完美数 123456789101112131415161718&quot;&quot;&quot;找出1~9999之间的所有完美数完美数是除自身外其他所有因子的和正好等于这个数本身的数例如: 6 = 1 + 2 + 3, 28 = 1 + 2 + 4 + 7 + 14&quot;&quot;&quot;&quot;&quot;import timeimport mathfor num in range(1, 10000): sum = 0 for factor in range(1, int(math.sqrt(num)) + 1): if num % factor == 0: sum += factor if factor &gt; 1 and num / factor != factor: sum += num / factor if sum == num: print(num) 12345678910111213141516def factorial(num): &quot;&quot;&quot; 求阶乘 :param num:非负整数 :return:阶乘 &quot;&quot;&quot; result = 1 for n in range(1, num + 1): result *= n return resultm = int(input(&apos;m = &apos;))n = int(input(&apos;n = &apos;))print(factorial(m)//factorial(n)//factorial(m - n)) 12345678910111213141516171819202122232425from random import randintdef roll_dice(n = 2): &quot;&quot;&quot; :param n: 色子个数 :return: n 个色字点数的和 &quot;&quot;&quot; sum = 0 for _ in range(n): sum += randint(1,6) return sumdef add(a=0,b=0,c=0): return a + b + cprint(roll_dice())print(roll_dice(3))print(roll_dice(n=4))print(add())print(add(1))print(add(1,2))print(add(1,2,3))print(add(3,2,1))print(add(b=500,c=1000,a=400)) 12345678910111213141516171819&quot;&quot;&quot;输入M和N计算C(M,N)太过于重复使用函数用def定义函数&quot;&quot;&quot;m = int(input(&apos;m = &apos;))n = int(input(&apos;n = &apos;))fm = 1for num in range(1, m + 1): fm *= numfn = 1for num in range(1, n + 1): fn *= numfmn = 1for num in range(1, m - n + 1): fmn *= numprint(fm // fn // fmn) 123456789101112131415161718192021222324252627282930313233343536373839404142434445&quot;&quot;&quot;Craps赌博游戏玩家摇两颗色子 如果第一次摇出7点或11点 玩家胜如果摇出2点 3点 12点 庄家胜 其他情况游戏继续玩家再次要色子 如果摇出7点 庄家胜如果摇出第一次摇的点数 玩家胜否则游戏继续 玩家继续摇色子玩家进入游戏时有1000元的赌注 全部输光游戏结束&quot;&quot;&quot;&quot;&quot;from random import randintmoney = 1000while money &gt; 0 : print(&apos;你的资产为:%d&apos;%money) needs_go_on = False while True: debt = int(input(&apos;请下注：&apos;)) if debt &gt; 0 and debt &lt;= money : break first = randint(1,6) + randint(1,6) print(&apos;玩家摇出了%d点。&apos;% first) if first == 7 or first == 11: print(&apos;玩家胜&apos;) money += debt elif first == 2 or first == 3 or first == 12 : print(&apos;庄家胜&apos;) money -= debt else: needs_go_on =True while needs_go_on : current = randint(1,6) + randint(1,6) print(&apos;玩家摇出来%d点&apos;%current) if current == 7: print(&apos;庄家胜！&apos;) money -= debt needs_go_on = False elif current == first: print(&apos;玩家胜!&apos;) money += debt needs_go_on = Falseprint(&apos;你破产了，游戏结束！&apos;) 1234567891011121314# 在参数名前面的*表示args是一个可变参数# 即在调用add函数时可以传入0个或多个参数def add(*args): total = 0 for val in args: total += val return totalprint(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))print(add(1, 3, 5, 7, 9)) moudle1 12def foo(): print(&apos;hello, world!&apos;) moudle2 12def foo(): print(&apos;goodbye, world!&apos;) test 123456789101112131415from module1 import foo# 输出hello, world!foo()from module2 import foo# 输出goodbye, world!foo()import module1 as m1import module2 as m2m1.foo()m2.foo() moudle3 123456789101112131415def foo(): passdef bar(): pass# __name__是Python中一个隐含的变量它代表了模块的名字# 只有被Python解释器直接执行的模块的名字才是__main__if __name__ == &apos;__main__&apos;: print(&apos;call foo()&apos;) foo() print(&apos;call bar()&apos;) bar() 1234567from module3 import *if __name__ == &apos;__main__&apos;: print(&apos;call foo()&apos;) foo() print(&apos;call bar()&apos;) bar() 1234567891011121314151617def foo(): b = &apos;hello&apos; def bar(): # Python中可以在函数内部再定义函数 c = True print(a) print(b) print(c) bar() # print(c) # NameError: name &apos;c&apos; is not definedif __name__ == &apos;__main__&apos;: a = 100 # print(b) # NameError: name &apos;b&apos; is not defined foo() 12345678def foo(): a = 200 print(a)if __name__ == &apos;__main__&apos;: a = 100 foo() print(a) 12345678910111213141516&quot;&quot;&quot;global 调用全局变量使用global关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，那么下面一行的代码就会定义变量a并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域&quot;&quot;&quot;def foo(): global a a = 200 print(a)if __name__ == &apos;__main__&apos;: a = 100 foo() print(a) nonlocal 12345678def f1(): a = 250 def f2(): nonlocal a a = 520 f2() print(a)f1() # 输出 520 在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收。事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措，同时也是对迪米特法则的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在函数调用结束后依然可以访问，这时候就需要使用闭包 字符串 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def main(): str1 = &apos;hello, world!&apos; # 通过len函数计算字符串的长度 print(len(str1)) # 13 # 获得字符串首字母大写的拷贝 print(str1.capitalize()) # Hello, world! # 获得字符串变大写后的拷贝 print(str1.upper()) # HELLO, WORLD! # 从字符串中查找子串所在位置 print(str1.find(&apos;or&apos;)) # 8 print(str1.find(&apos;shit&apos;)) # -1 # 与find类似但找不到子串时会引发异常 print(str1.index(&apos;or&apos;)) #print(str1.index(&apos;shit&apos;)) # 检查字符串是否以指定的字符串开头 print(str1.startswith(&apos;He&apos;)) # False print(str1.startswith(&apos;hel&apos;)) # True # 检查字符串是否以指定的字符串结尾 print(str1.endswith(&apos;!&apos;)) # True # 将字符串以指定的宽度居中并在两侧填充指定的字符 print(str1.center(50, &apos;*&apos;)) # 将字符串以指定的宽度靠右放置左侧填充指定的字符 print(str1.rjust(50, &apos; &apos;)) str2 = &apos;abc123456&apos; # 从字符串中取出指定位置的字符(下标运算) print(str2[2]) # c # 字符串切片(从指定的开始索引到指定的结束索引) print(str2[2:5]) # c12 print(str2[2:]) # c123456 print(str2[2::2]) # c246 print(str2[::2]) # ac246 print(str2[::-1]) # 654321cba print(str2[-3:-1]) # 45 # 检查字符串是否由数字构成 print(str2.isdigit()) # False # 检查字符串是否以字母构成 print(str2.isalpha()) # False # 检查字符串是否以数字和字母构成 print(str2.isalnum()) # True str3 = &apos; www.python365.club &apos; print(str3) # 获得字符串修剪左右两侧空格的拷贝 print(str3.strip())if __name__ == &apos;__main__&apos;: main() list列表 1234567891011121314151617181920212223242526272829303132333435363738394041424344def main(): list1 = [1, 3, 5, 7, 100] print(list1) list2 = [&apos;hello&apos;] * 5 print(list2) # 计算列表长度(元素个数) print(len(list1)) # 下标(索引)运算 print(list1[0]) print(list1[1]) print(list1[4]) # print(list1[5]) # IndexError: list index out of range print(list1[-1]) print(list1[-3]) list1[2] = 300 print(list1) # 添加元素 list1.append(200) # 插入元素 list1.insert(1, 400) list1 += [1000, 2000] print(list1) print(len(list1)) print(list1) # 删除元素 list1.remove(3) print(list1) if 1 in list1: list1.remove(2000) #该方法没有返回值但是会移除列表中的某个值的第一个匹配项。 print(list1) del list1[0] print(list1) list1.pop() print(list1) # 清空列表元素 list1.clear() print(list1)if __name__ == &apos;__main__&apos;: main() 1234567891011121314151617181920212223def main(): fruits = [&apos;grape&apos;, &apos;apple&apos;, &apos;strawberry&apos;, &apos;waxberry&apos;] fruits += [&apos;pitaya&apos;, &apos;pear&apos;, &apos;mango&apos;] # 循环遍历列表元素 for fruit in fruits: print(fruit.title(), end=&apos; &apos;) print() # 列表切片 fruits2 = fruits[1:4] print(fruits2) # fruit3 = fruits # 没有复制列表只创建了新的引用 # 可以通过完整切片操作来复制列表 fruits3 = fruits[:] print(fruits3) fruits4 = fruits[-3:-1] print(fruits4) # 可以通过反向切片操作来获得倒转后的列表的拷贝 fruits5 = fruits[::-1] print(fruits5)if __name__ == &apos;__main__&apos;: main() sorted sort 与 sorted 区别： sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。 list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。 1234567891011121314151617181920212223242526&quot;&quot;&quot;cmp – 可选参数, 如果指定了该参数会使用该参数的方法进行排序。key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。reverse – 排序规则，reverse = True 降序， reverse = False 升序（默认&quot;&quot;&quot;def main(): list1 = [&apos;orange&apos;, &apos;apple&apos;, &apos;zoo&apos;, &apos;internationalization&apos;, &apos;blueberry&apos;] list2 = sorted(list1) # sorted函数返回列表排序后的拷贝不会修改传入的列表 # 函数的设计就应该像sorted函数一样尽可能不产生副作用 list3 = sorted(list1, reverse=True) # 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序 list4 = sorted(list1, key=len) print(list1) print(list2) print(list3) print(list4) # 给列表对象发出排序消息直接在列表对象上进行排序 list1.sort(reverse=True) print(list1) list1.sort(reverse=False) print(list1)if __name__ == &apos;__main__&apos;: main() 元组 使用元组 Python 的元组与列表类似，不同之处在于元组的元素不能修改，在前面的代码中我们已经不止一次使用过元组了。顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组。 123456789101112131415161718192021222324252627282930def main(): # 定义元组 t = (&apos;骆昊&apos;, 38, True, &apos;四川成都&apos;) print(t) # 获取元组中的元素 print(t[0]) print(t[3]) # 遍历元组中的值 for member in t: print(member) # 重新给元组赋值 # t[0] = &apos;王大锤&apos; # TypeError # 变量t重新引用了新的元组原来的元组将被垃圾回收 t = (&apos;王大锤&apos;, 20, True, &apos;云南昆明&apos;) print(t) # 将元组转换成列表 person = list(t) print(person) # 列表是可以修改它的元素的 person[0] = &apos;李小龙&apos; person[1] = 25 print(person) # 将列表转换成元组 fruits_list = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;] fruits_tuple = tuple(fruits_list) print(fruits_tuple)if __name__ == &apos;__main__&apos;: main() 这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？ 元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。 元组在创建时间和占用的空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在ipython中使用魔法指令%timeit来分析创建同样内容的元组和列表所花费的时间，下图是我的macOS系统上测试的结果。 集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def main(): set1 = &#123;1, 2, 3, 3, 3, 2&#125; print(set1) print(&apos;Length =&apos;, len(set1)) set2 = set(range(1, 10)) print(set2) set1.add(4) set1.add(5) set2.update([11, 12]) print(&apos;set1 = &apos;,set1) print(&apos;set2 = &apos;,set2) set2.discard(5) # remove的元素如果不存在会引发KeyError if 4 in set2: set2.remove(4) print(set2) # 遍历集合容器 for elem in set2: print(elem ** 2, end=&apos; &apos;) print() # 将元组转换成集合 set3 = set((1, 2, 3, 3, 2, 1)) print(set3.pop()) print(set3) print(&apos;set1 = &apos;,set1) print(&apos;set2 = &apos;,set2) # 集合的交集、并集、差集、对称差运算 print(set1 &amp; set2) # print(set1.intersection(set2)) print(set1 | set2) # print(set1.union(set2)) print(set1 - set2) # print(set1.difference(set2)) print(set1 ^ set2) # print(set1.symmetric_difference(set2)) print(&apos;set1 = &apos;,set1) print(&apos;set2 = &apos;,set2) print(&apos;set3 = &apos;,set3) # 判断子集和超集 print(set2 &lt;= set1) # print(set2.issubset(set1)) print(set3 &lt;= set1) # print(set3.issubset(set1)) print(set1 &gt;= set2) # print(set1.issuperset(set2)) print(set1 &gt;= set3) # print(set1.issuperset(set3))if __name__ == &apos;__main__&apos;: main() 字典 123456789101112131415161718192021222324252627282930def main(): scores = &#123;&apos;骆昊&apos;: 95, &apos;白元芳&apos;: 78, &apos;狄仁杰&apos;: 82&#125; # 通过键可以获取字典中对应的值 print(scores[&apos;骆昊&apos;]) print(scores[&apos;狄仁杰&apos;]) # 对字典进行遍历(遍历的其实是键再通过键取对应的值) for elem in scores: print(&apos;%s\t---&gt;\t%d&apos; % (elem, scores[elem])) # 更新字典中的元素 scores[&apos;白元芳&apos;] = 65 scores[&apos;诸葛王朗&apos;] = 71 scores.update(冷面=67, 方启鹤=85, 武则天=100) print(scores) if &apos;武则天&apos; in scores: print(scores[&apos;武则天&apos;]) print(scores.get(&apos;武则天&apos;)) # get方法也是通过键获取对应的值但是可以设置默认值 print(scores.get(&apos;武则天&apos;, 60)) # 删除字典中的元素 print(scores.popitem()) print(scores.popitem()) print(scores.pop(&apos;骆昊&apos;, 100)) # 清空字典 scores.clear() print(scores)if __name__ == &apos;__main__&apos;: main() 双色球 random.sample随机取样 12345678910111213141516171819202122232425262728293031323334from random import randrange, randint, sampledef display(balls): &quot;&quot;&quot; 输出列表中的双色球号码 &quot;&quot;&quot; for index, ball in enumerate(balls): if index == len(balls) - 1: print(&apos;|&apos;, end=&apos; &apos;) print(&apos;%02d&apos; % ball, end=&apos; &apos;) print()def random_select(): &quot;&quot;&quot; 随机选择一组号码 &quot;&quot;&quot; red_balls = [x for x in range(1, 34)] selected_balls = [] selected_balls = sample(red_balls, 6) selected_balls.sort() selected_balls.append(randint(1, 16)) return selected_ballsdef main(): n = int(input(&apos;机选几注: &apos;)) for _ in range(n): display(random_select())if __name__ == &apos;__main__&apos;: main() 杨辉三角 12345678910111213141516def main(): num = int(input(&apos;Number of rows: &apos;)) yh = [[]] * num for row in range(len(yh)): yh[row] = [None] * (row + 1) for col in range(len(yh[row])): if col == 0 or col == row: yh[row][col] = 1 else: yh[row][col] = yh[row - 1][col] + yh[row - 1][col - 1] print(yh[row][col], end=&apos;\t&apos;) print()if __name__ == &apos;__main__&apos;: main() 跑马灯 1234567891011121314151617import osimport timedef main(): content = &apos;北京欢迎你为你开天辟地…………&apos; while True: # 清理屏幕上的输出 os.system(&apos;cls&apos;) # os.system(&apos;clear&apos;) print(content) # 休眠200毫秒 time.sleep(0.2) content = content[1:] + content[0]if __name__ == &apos;__main__&apos;: main() 1234567891011121314151617181920212223242526272829303132333435363738def is_leap_year(year): &quot;&quot;&quot; 判断指定的年份是不是闰年 :param year: 年份 :return: 闰年返回True平年返回False &quot;&quot;&quot; return year % 4 == 0 and year % 100 != 0 or year % 400 == 0def which_day(year, month, date): &quot;&quot;&quot; 计算传入的日期是这一年的第几天 :param year: 年 :param month: 月 :param date: 日 :return: 第几天 &quot;&quot;&quot; days_of_month = [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] ][is_leap_year(year)] total = 0 for index in range(month - 1): total += days_of_month[index] return total + datedef main(): print(&apos;这一年的第%d天&apos;%which_day(1980, 11, 28)) print(&apos;这一年的第%d天&apos;%which_day(1981, 12, 31)) print(&apos;这一年的第%d天&apos;%which_day(2018, 1, 1)) print(&apos;这一年的第%d天&apos;%which_day(2016, 3, 1))if __name__ == &apos;__main__&apos;: main() 约瑟夫环 123456789101112131415161718192021222324252627&quot;&quot;&quot;《幸运的基督徒》有15个基督徒和15个非基督徒在海上遇险，为了能让一部分人活下来不得不将其中15个人扔到海里面去，有个人想了个办法就是大家围成一个圈，由某个人开始从1报数，报到9的人就扔到海里面，他后面的人接着从1开始报数，报到9的人继续扔到海里面，直到扔掉15个人。由于上帝的保佑，15个基督徒都幸免于难，问这些人最开始是怎么站的，哪些位置是基督徒哪些位置是非基督徒。&quot;&quot;&quot;def main(): persons = [True] * 30 counter, index, number = 0, 0, 0 while counter &lt; 15: if persons[index]: number += 1 if number == 9: persons[index] = False counter += 1 number = 0 index += 1 index %= 30 for person in persons: print(&apos;基&apos; if person else &apos;非&apos;, end=&apos;&apos;)if __name__ == &apos;__main__&apos;: main() 验证码 12345678910111213141516171819202122232425262728293031import randomdef generate_code(code_len=4): &quot;&quot;&quot; 生成指定长度的验证码 :param code_len: 验证码的长度(默认4个字符) :return: 由大小写英文字母和数字构成的随机验证码 &quot;&quot;&quot; all_chars = &apos;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos; last_pos = len(all_chars) - 1 code = &apos;&apos; for _ in range(code_len): index = random.randint(0, last_pos) code += all_chars[index] return codedef main(): stl1 = generate_code() print(&apos;验证码为：%a&apos; % stl1) yz = input(&apos;请输入验证码:&apos;) if yz == stl1: print(&apos;验证码正确！&apos;) else: print(&apos;验证码错误！！&apos;)if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
